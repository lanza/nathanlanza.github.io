<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Type-erasure, protocols with associated types and generics from a simple example.</title>
  <meta name="description" content="The other day I was writing some code and went a bit too generic happy with all my classes. A simplified version started with some code like this:">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://lanza.io/swift/2016/08/29/TypeErasure.html">
  <link rel="alternate" type="application/rss+xml" title="Nathan Lanza" href="https://lanza.io/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Nathan Lanza</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/portfolio/">Portfolio</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Type-erasure, protocols with associated types and generics from a simple example.</h1>
    <p class="post-meta"><time datetime="2016-08-29T07:54:00-04:00" itemprop="datePublished">Aug 29, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <p>The other day I was writing some code and went a bit too generic happy with all my classes. A simplified version started with some code like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">NumberHolder</span> <span class="p">{</span>
   <span class="k">var</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span>
   <span class="k">weak</span> <span class="k">var</span> <span class="nv">delegate</span><span class="p">:</span> <span class="kt">NumberHolderDelegate</span><span class="p">?</span>
   <span class="kd">func</span> <span class="nf">printNumber</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
      <span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="n">number</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="kd">protocol</span> <span class="kt">NumberHolderDelegate</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>This is a pretty simple pattern. You have a type which must delegate responsibilty to some other type. This simple and contrived example gets the point across. A more practical example would be a UITableViewCell with a button on it. When the button is clicked, the cell is in no position to make any decision or to do any work for the user, so it delegates the action backwards towards it’s delegate which is some UIViewController subclass.</p>

<p>From here, I wanted to be more “Swifty” and make my code generic for maximum reusability. I wanted NumberHolder to work for Doubles, too(or any other type, in fact.)</p>

<p>(Note: this code below doesn’t work.)</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">NumberHolder</span><span class="o">&lt;</span><span class="kt">Number</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">var</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span>
   <span class="k">weak</span> <span class="k">var</span> <span class="nv">delegate</span><span class="p">:</span> <span class="kt">NumberHolderDelegate</span><span class="p">?</span>
   <span class="kd">func</span> <span class="nf">printNumber</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
      <span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="n">number</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="kd">protocol</span> <span class="kt">NumberHolderDelegate</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>The delegate clearly doesn’t know what type of object to expect. It has to be told that it will receive a generic type.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">protocol</span> <span class="kt">NumberHolderDelegate</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>However, it doesn’t know what a “Number” is. This is where the famous associatedtype comes in.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">protocol</span> <span class="kt">NumberHolderDelegate</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
   <span class="k">associatedtype</span> <span class="kt">Number</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Great! The delegate makes sense. But now we have the famous error that confuses so many about protocols with associated types.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">protocol</span> <span class="err">'</span><span class="kt">NumberHolderDelegate</span><span class="err">'</span> <span class="n">can</span> <span class="n">only</span> <span class="n">be</span> <span class="n">used</span> <span class="k">as</span> <span class="n">a</span> <span class="n">generic</span> <span class="n">constraint</span> <span class="n">because</span> <span class="n">it</span> <span class="n">has</span> <span class="k">Self</span> <span class="n">or</span> <span class="n">associated</span> <span class="n">type</span> <span class="n">requirements</span></code></pre></figure>

<p>What does this mean? Well, the problem is that the NumberHolder type referes to a variable of the type NumberHolderDelegate. When the compiler goes to check that property, it requires to know what the associatedtype “Number” is. However, simply declaring “NumberHolderDelegate” doesn’t tell the compiler this. “associatedtype Number” is a statement of “to be determined later” or “to be determined by some other means.” We have to tell the compiler what that type is going to be. How? One way is through generics. The NumberHolder class turns into this:</p>

<p>(Note: this still doesn’t work quite yet.)</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">NumberHolder</span><span class="o">&lt;</span><span class="kt">Number</span><span class="p">,</span> <span class="kt">Delegate</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">Delegate</span><span class="p">:</span> <span class="kt">NumberHolderDelegate</span> <span class="p">{</span>
   <span class="k">var</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="o">!</span>
   <span class="k">weak</span> <span class="k">var</span> <span class="nv">delegate</span><span class="p">:</span> <span class="kt">Delegate</span><span class="p">?</span>
   <span class="kd">func</span> <span class="nf">printNumber</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
      <span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="n">number</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We make NumberHolder generic over the type Delegate and tell the compiler that Delegate is a NumberHolderDelegate. Almost working. However, that was only half the fix. The compiler still doens’t know what the associatedtype “Number” is. Here’s how we tell it this information:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">NumberHolder</span><span class="o">&lt;</span><span class="kt">Number</span><span class="p">,</span> <span class="kt">Delegate</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">Delegate</span><span class="p">:</span> <span class="kt">NumberHolderDelegate</span><span class="p">,</span> <span class="kt">Delegate</span><span class="o">.</span><span class="kt">Number</span> <span class="o">==</span> <span class="kt">Number</span> <span class="p">{</span>
   <span class="k">var</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="o">!</span>
   <span class="k">weak</span> <span class="k">var</span> <span class="nv">delegate</span><span class="p">:</span> <span class="kt">Delegate</span><span class="p">?</span>
   <span class="kd">func</span> <span class="nf">printNumber</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
      <span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="n">number</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The added clause “Delegate.Number == Number” tells the compiler that the type Delegate is (first of all a NumberHolderDelegate, but it already knew that from the first clause) declared with an associatedtype of the same type that the NumberHolder is. So upon creation of a NumberHolder:</p>

<p>(Note: this STILL isn’t correct as the second generic type isn’t being declared.)</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">numberHolder</span> <span class="o">=</span> <span class="kt">NumberHolder</span><span class="o">&lt;</span><span class="kt">Double</span><span class="p">,</span> <span class="p">(</span><span class="kt">Placeholder</span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span>
<span class="n">numberHolder</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="mf">3.14</span></code></pre></figure>

<p>the compiler can (almost) infer what is going on. First, we tell it that the instance is NumberHolder&lt;Double,(Placeholder)&gt;. From the first where clause, the compiler knows that Delegate is a NumberHolderDelegate. From the second clause, the compiler knows that the Delegate’s associatedtype Number is going to be == to the NumberHolders generic type Number. In this case, that means the associatedtype is a Double.</p>

<p>However, the compiler hasn’t been told exactly what object is going to take the place of the second generic type. In typical practices, you simply do someting like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">SomeOtherClass</span><span class="p">:</span> <span class="kt">NumberHolderDelegate</span> <span class="p">{</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//do something</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This creates a type that can serve as the delegate to the NumberHolder specific to the type Int. We can also make this generic as well:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">SomeOtherClass</span><span class="o">&lt;</span><span class="kt">Number</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">NumberHolderDelegate</span> <span class="p">{</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//do something</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Now this class will work with any NumberHolder regardless of type. Now about this time, I realized I accidentally stumbled upon type-erasure. We just created a class (SomeOtherClass) that lets us hide away the NumberHolderDelegate from the NumberHolder and just accept any SomeOtherClass. In fact, this is where the naming “AnySuchAndSuch” comes from. We’ll convert to this convention:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">AnyNumberHolderDelegate</span><span class="o">&lt;</span><span class="kt">Number</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">NumberHolderDelegate</span> <span class="p">{</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//do something</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This enables us to remove the second generic type from NumberHolder and all it’s where clauses:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">NumberHolder</span><span class="o">&lt;</span><span class="kt">Number</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">var</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="o">!</span>
   <span class="k">weak</span> <span class="k">var</span> <span class="nv">delegate</span><span class="p">:</span> <span class="kt">AnyNumberHolderDelegate</span><span class="o">&lt;</span><span class="kt">Number</span><span class="o">&gt;</span><span class="p">?</span>
   <span class="kd">func</span> <span class="nf">printNumber</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
      <span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="n">number</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This is a MUCH nicer class declaration. We traded an intermediary class, the AnyNumberHolderDelegate, for one generic type and two where clauses.</p>

<p>One last caveat: this isn’t EXACTLY type erasure. Typically type erasure merely copies the delegate function (or receives a closure in it’s initializer) that serves as the delegate function. A truly type erased delegate would be as such:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">AnyNumberHolderDelegate</span><span class="o">&lt;</span><span class="kt">Number</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">NumberHolderDelegate</span> <span class="p">{</span>
   <span class="k">var</span> <span class="nv">closure</span><span class="p">:</span> <span class="p">((</span><span class="kt">Number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span>
   <span class="nf">init</span><span class="p">(</span><span class="nv">closure</span><span class="p">:</span> <span class="p">((</span><span class="kt">Number</span><span class="p">)</span> <span class="o">-&gt;</span><span class="p">())</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="o">.</span><span class="n">closure</span> <span class="o">=</span> <span class="n">closure</span>
   <span class="p">}</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">closure</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And this is our type-erased class to serve as the delegate to our NumberHolder class. Alltogether we have:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">NumberHolder</span><span class="o">&lt;</span><span class="kt">Number</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">var</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="o">!</span>
   <span class="k">weak</span> <span class="k">var</span> <span class="nv">delegate</span><span class="p">:</span> <span class="kt">AnyNumberHolderDelegate</span><span class="o">&lt;</span><span class="kt">Number</span><span class="o">&gt;</span><span class="p">?</span>
   <span class="kd">func</span> <span class="nf">printNumber</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"Number holder prints: "</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span>
      <span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="n">number</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">NumberHolderDelegate</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
   <span class="k">associatedtype</span> <span class="kt">Number</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">AnyNumberHolderDelegate</span><span class="o">&lt;</span><span class="kt">Number</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">NumberHolderDelegate</span> <span class="p">{</span>
   <span class="k">var</span> <span class="nv">closure</span><span class="p">:</span> <span class="p">((</span><span class="kt">Number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span>
   <span class="nf">init</span><span class="p">(</span><span class="nv">closure</span><span class="p">:</span> <span class="p">((</span><span class="kt">Number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()))</span> <span class="p">{</span>
      <span class="k">self</span><span class="o">.</span><span class="n">closure</span> <span class="o">=</span> <span class="n">closure</span>
   <span class="p">}</span>
   <span class="kd">func</span> <span class="nf">didPrint</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Number</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">closure</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">numberHolder</span> <span class="o">=</span> <span class="kt">NumberHolder</span><span class="o">&lt;</span><span class="kt">Double</span><span class="o">&gt;</span><span class="p">()</span>
<span class="n">numberHolder</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="mf">3.14</span>
<span class="k">let</span> <span class="nv">numberHolderDelegate</span> <span class="o">=</span> <span class="kt">AnyNumberHolderDelegate</span><span class="o">&lt;</span><span class="kt">Double</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">number</span> <span class="k">in</span>
   <span class="nf">print</span><span class="p">(</span><span class="s">"AnyNumberHolderDelegate prints: "</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">numberHolder</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">numberHolderDelegate</span>
<span class="n">numberHolder</span><span class="o">.</span><span class="nf">printNumber</span><span class="p">()</span>

<span class="c1">// Number holder prints: 3.14</span>
<span class="c1">// AnyNumberHolderDelegate prints: 3.14</span></code></pre></figure>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Nathan Lanza</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Nathan Lanza</li>
          <li><a href="mailto:nathan@lanza.io">nathan@lanza.io</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/nathanlanza"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">nathanlanza</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/nlanzaio"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">nlanzaio</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Somehwere I can write about Swift, iOS and quantum field theory...</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
